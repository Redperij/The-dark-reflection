### Some blocks of code from on_actions have been moved here for readability and reusability

apply_cosmetic_tags_on_puppet_PREV_is_overlord = {

}

AI_puppet_to_annex = {
	if = {
		limit = { FROM = { is_ai = yes } }
		if = {
			limit = {
				ROOT = {
					all_owned_state = {
						OR = {
							is_core_of = FROM
							is_claimed_by = FROM
						}
					}
				}
			}
			FROM = { annex_country = { target = ROOT } }
		}
		else = {
			every_owned_state = {
				limit = {
					OR = {
						is_core_of = FROM
						is_claimed_by = FROM
					}
				}
				FROM = { transfer_state = PREV }
			}
		}
	}
}

transfer_society_and_science_ideas_when_released = {
	hidden_effect = {
		if = {
			limit = {
				FROM = {
					NOT = { has_idea = modern_society }
				}
			}
			FROM = { ROOT = { transfer_society_ideas = yes } }
		}
		else = {
			add_ideas = modern_society
		}
		if = {
			limit = {
				FROM = {
					NOT = { has_idea = proper_science_base }
				}
			}
			FROM = { ROOT = { transfer_science_ideas = yes } }
		}
		else = {
			add_ideas = proper_science_base
		}
		if = {
			limit = {
				FROM = {
					NOT = { has_idea = no_poverty }
				}
			}
			FROM = { ROOT = { transfer_poverty_ideas = yes } }
		}
		else = {
			add_ideas = no_poverty
		}
		if = {
			limit = {
				FROM = {
					NOT = { has_idea = no_lack_of_scientists }
				}
			}
			FROM = { ROOT = { transfer_illiteracy_ideas = yes } }
		}
		else = {
			add_ideas = no_lack_of_scientists
		}
	}
}

handle_generic_griffon_ideas_on_govt_change = {
	if = {
		limit = {
			OR = {
				has_idea = griffon_neutrality_support_idea
				has_idea = griffon_monarchy_support_idea
			}
			NOT = { has_government = neutrality }
		}
		remove_ideas = { griffon_monarchy_support_idea griffon_neutrality_support_idea }
	}
	if = {
		limit = {
			OR = {
				has_idea = griffon_monarchy_dem_support_idea
				has_idea = griffon_harmony_support_idea
			}
			NOT = { has_government = democratic }
		}
		remove_ideas = { griffon_monarchy_dem_support_idea griffon_harmony_support_idea }
	}
	if = {
		limit = {
			OR = {
				has_idea = griffon_fascism_support_idea
				has_idea = griffon_monarchy_fas_support_idea
			}
			NOT = { has_government = fascism }
		}
		remove_ideas = { griffon_monarchy_fas_support_idea griffon_fascism_support_idea }
	}
	if = {
		limit = {
			has_idea = griffon_communism_support_idea
			NOT = { has_government = communism }
		}
		remove_ideas = griffon_communism_support_idea
	}
}

handle_op_paperclip = {
	for_each_scope_loop = {
		array = FROM.core_states
		add_to_variable = { FROM.industry_value = industrial_complex_level }
		add_to_variable = { FROM.industry_value = arms_factory_level }
	}
	for_each_scope_loop = {
		array = FROM.core_states
		set_state_flag = op_paperclip_state
		set_variable = { previous_owner = FROM.id }
		set_variable = { previous_owner_industry_value = FROM.industry_value }
	}
	FROM = { clear_variable = industry_value }
	country_event = oppaperclip.1
}

set_have_regular_puppets = {
	if = {
		limit = {
			is_feudal_vassal = yes
			NOT = {
				has_country_flag = have_regular_puppets
			}
			FROM = { has_country_flag = have_regular_puppets }
		}
		#kill_country_leader = yes
		set_country_flag = have_regular_puppets
	}
}

# research workaround to apply the pre 1.6 research speed function by Yard1
# before 1.6, research speed was linear, and had the equation:
#
# time = (cost-(cost/100)*x)/(speed)
#
# the research speed modifier was applied to the tech cost, so if we had a tech that had a base cost of 100 days, a research speed modifier of +50% would bring that to 50 days
# after 1.6, the equation changed to:
#
# time = (cost)/(speed-(speed/100)*x)
#
# now the research speed modifier was applied to the speed itself (aka daily research gain). Which meant that, if we had a +50% research speed modifier, the 100 days tech would take 66.67 days
# this modifier adds just the right amount of the research speed modifier to make the new equation give the same results as the old one. Without it, we would not be able to have
# very large maluses, as the research would take an infinite amount of days
adjust_research_modifier = {
	if = {
		limit = {
			NOT = {
				has_dynamic_modifier = {
					modifier = research_pre_ironclad_modifier
				}
			}
		}
		add_dynamic_modifier = {
			modifier = research_pre_ironclad_modifier
		}
	}
	set_temp_variable = { research_speed = modifier@research_speed_factor }
	subtract_from_temp_variable = { research_speed = var_research_adjustment_pre_ironclad }
	if = {
		limit = {
			check_variable = { research_speed < -0.1 }
		}
		set_temp_variable = { var_research_adjustment_pre_ironclad_temp = 1 }
		set_variable = { var_research_adjustment_pre_ironclad = 1 }
		subtract_from_temp_variable = { var_research_adjustment_pre_ironclad_temp = research_speed }
		if = {
			limit = {
				check_variable = {
					var = research_speed
					value = 1
					compare = greater_than_or_equals
				}
			}
			set_temp_variable = { var_research_adjustment_pre_ironclad_temp = 0.001 }
		}
		divide_variable = { var_research_adjustment_pre_ironclad = var_research_adjustment_pre_ironclad_temp }
		subtract_from_variable = { var_research_adjustment_pre_ironclad = 1 }
		subtract_from_variable = { var_research_adjustment_pre_ironclad = research_speed }
	}
	else = {
		set_variable = { var_research_adjustment_pre_ironclad = 0 }
	}
}

print_majors_array = {
	for_each_scope_loop = {
		array = global.majors
		log = "global.majors: [This.GetName]"
	}
}

# in on_daily, ran for every country

# for one country

WORKAROUND_civil_war_load_tree_for_revolter = {
	hidden_effect = {
		
	}
}

# HoI4 State Land Connection Indexer by Yard1
# Provides a simple way to check if two states share a land connection
# Call the scripted effect below in on_startup from a country scope (any will do, I suggest random_country)
# In order to check if two states have a land connection to each other, compare their state_land_connection_index variables. If they are the same, then they have a land connection.
mark_land_connected_states = {
	random_country = {
		set_variable = { global.current_state_land_connection_index = 1 }
		every_state = {
			add_to_array = { global.unchecked_land_connection_states = THIS }
		}
		while_loop_effect = {
			limit = {
				check_variable = { global.unchecked_land_connection_states^num > 0 }
			}
			#log = "Run land connection loop with index [?global.current_state_land_connection_index|0], [?global.unchecked_land_connection_states^num|0] states left to index"
			var:global.unchecked_land_connection_states^0 = {
				#log = "Adding index [?global.current_state_land_connection_index|0] to [?this.GetName]"
				set_variable = { state_land_connection_index = global.current_state_land_connection_index }
				every_neighbor_state = {
					#log = "Adding index [?global.current_state_land_connection_index|0] to [?this.GetName], neighbor of [?prev.GetName]"
					set_variable = { state_land_connection_index = global.current_state_land_connection_index }
					if = {
						limit = { is_in_array = { global.unchecked_land_connection_states = THIS } }
						remove_from_array = { global.unchecked_land_connection_states = THIS }
					}
				}
				remove_from_array = { global.unchecked_land_connection_states = THIS }
			}
			set_temp_variable = { temp_lc_state = 0 }
			while_loop_effect = {
				limit = {
					any_of = {
						array = global.unchecked_land_connection_states
						var:v = {
							any_neighbor_state = { has_variable = state_land_connection_index }
						}
						set_temp_variable = { global.temp_lc_state = v }
					}
				}
				if = {
					limit = { NOT = { check_variable = { temp_lc_state = 0 } } }
					#log = "Found [?temp_lc_state.GetName] as a neighbor of an indexed state"
					var:temp_lc_state = {
						#log = "Adding index [?global.current_state_land_connection_index|0] to [?this.GetName]"
						set_variable = { state_land_connection_index = global.current_state_land_connection_index }
						remove_from_array = { global.unchecked_land_connection_states = THIS }
						every_neighbor_state = {
							#log = "Adding index [?global.current_state_land_connection_index|0] to [?this.GetName], neighbor of [?prev.GetName]"
							set_variable = { state_land_connection_index = global.current_state_land_connection_index }
							if = {
								limit = { is_in_array = { global.unchecked_land_connection_states = THIS } }
								remove_from_array = { global.unchecked_land_connection_states = THIS }
							}
						}
					}
				}
			}
			#log = "Land connection loop done, [?global.unchecked_land_connection_states^num|0] states left to index"
			#log = "----"
			add_to_variable = { global.current_state_land_connection_index = 1 }
		}
		clear_variable = global.current_state_land_connection_index
		clear_array = global.unchecked_land_connection_states
	}
}

# We want to be able to determine whether a puppet wargoal was used during peace conferences
# however, declaring war makes wargoals poof. This works around that
# FROM is war target
save_puppet_wargoals = {
	clear_puppet_wargoals = yes
	if = {
		limit = {
			has_wargoal_against = { target = FROM type = puppet_wargoal_focus }
			NOT = {
				is_in_array = {
					puppet_wargoals_war = FROM
				}
			}
		}
		add_to_array = {
			puppet_wargoals_war = FROM
		}
	}
}

clear_puppet_wargoals = {
	country_event = {
		id = utility.16
		hours = 1
	}
}

clear_puppet_wargoals_do = {
	clear_temp_array = puppet_wargoals_war_to_remove
	for_each_scope_loop = {
		array = puppet_wargoals_war
		if = {
			limit = {
				OR = {
					exists = no
					has_war = no
				}
			}
			add_to_temp_array = { puppet_wargoals_war_to_remove = THIS }
		}
	}
	for_each_loop = {
		array = puppet_wargoals_war_to_remove
		remove_from_array = {
			array = puppet_wargoals_war
			value = var:v
		}
	}
	if = {
		limit = {
			check_variable = { puppet_wargoals_war^num = 0 }
		}
		clear_array = puppet_wargoals_war
	}
}
